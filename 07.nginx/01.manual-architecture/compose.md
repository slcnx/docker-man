# Docker Compose Nginx 架构解读完整实践指南

## 📚 第一部分：Nginx 基础知识

### 1.1 什么是 Nginx

Nginx 是一个强大而灵活的**高性能 Web 服务器软件**，适用于处理高流量、高并发的 Web 应用程序，同时具有反向代理、负载均衡、静态文件服务等多种功能。

#### Nginx 的特点

| 特性 | 说明 | 优势 |
|------|------|------|
| **高并发** | 支持数万并发连接 | 异步非阻塞 I/O 模型 |
| **低资源消耗** | 内存占用少，CPU 消耗低 | 事件驱动架构 |
| **模块化** | 功能模块化，易于扩展 | 丰富的核心和第三方模块 |
| **高可靠性** | 稳定运行，故障恢复能力强 | Master-Worker 架构 |
| **灵活配置** | 配置简洁，功能强大 | 支持热加载、平滑升级 |

#### Nginx 发展历史

| 时间 | 事件 | 说明 |
|------|------|------|
| **2002 年** | 开发启动 | 伊戈尔·赛索耶夫为 Rambler.ru 开发 |
| **2004-10-04** | 首次发布 | 版本号 0.1.0 |
| **2019-03** | F5 收购 | 总价值约 6.7 亿美元 |
| **至今** | 持续更新 | 社区版和商业版并行发展 |

**代码价值**：Nginx 核心代码约 19.8 万行，每行代码价值约 2.2 万人民币。

---

### 1.2 Nginx 版本分类

#### 版本类型对比

| 版本类型 | 版本号规则 | 特点 | 推荐场景 |
|---------|----------|------|---------|
| **Mainline（主线版）** | 奇数（如 1.25.x） | 最新功能、实验性特性 | 开发测试环境 |
| **Stable（稳定版）** | 偶数（如 1.26.x） | 经过充分测试，稳定可靠 | **生产环境（推荐）** |
| **Legacy（历史版）** | 偶数（已归档） | 不再维护 | 不推荐使用 |

#### 版本选择建议

```
┌──────────────────────────────────────────────────────┐
│                   版本选择决策树                       │
├──────────────────────────────────────────────────────┤
│                                                        │
│  生产环境？                                            │
│    ├─ 是 → Stable 版本（偶数版本号）                  │
│    │       • 稳定可靠                                  │
│    │       • 已知问题少                                │
│    │       • 适合长期运行                              │
│    │                                                   │
│    └─ 否（开发/测试）→ Mainline 版本（奇数版本号）     │
│              • 最新功能                                │
│              • 性能优化                                │
│              • 可能存在未知问题                        │
│                                                        │
└──────────────────────────────────────────────────────┘
```

**官方资源**：
- 下载页面：https://nginx.org/en/download.html
- 安装源配置：https://nginx.org/en/linux_packages.html

---

## 🏗️ 第二部分：Nginx 架构解读

### 2.1 Nginx 架构概览

#### 2.1.1 架构示意图

```
┌────────────────────────────────────────────────────────────┐
│                        客户端（Client）                     │
│                   HTTP/HTTPS 请求 ↓                         │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│                        Nginx 服务器                         │
│  ┌─────────────────────────────────────────────────────┐  │
│  │             Master 进程（管理进程）                  │  │
│  │  • 读取和验证配置文件                                │  │
│  │  • 创建和管理 Worker 进程                            │  │
│  │  • 处理管理员信号                                    │  │
│  │  • 不处理实际的客户端请求                            │  │
│  └────────────┬───────────────────────────┬──────────────┘  │
│               ↓                           ↓                 │
│  ┌────────────────────────┐  ┌────────────────────────┐    │
│  │  Worker 进程 1         │  │  Worker 进程 N         │    │
│  │  • 处理客户端请求      │  │  • 处理客户端请求      │    │
│  │  • 异步非阻塞 I/O      │  │  • 异步非阻塞 I/O      │    │
│  │  • 事件驱动模型        │  │  • 事件驱动模型        │    │
│  │  • 单线程处理多连接    │  │  • 单线程处理多连接    │    │
│  └───────────┬────────────┘  └───────────┬────────────┘    │
│              ↓                           ↓                  │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              Nginx 模块层                            │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐             │  │
│  │  │Core      │ │HTTP      │ │Stream    │  核心模块   │  │
│  │  │Module    │ │Module    │ │Module    │             │  │
│  │  └──────────┘ └──────────┘ └──────────┘             │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐             │  │
│  │  │Proxy     │ │FastCGI   │ │SSL       │  基础模块   │  │
│  │  │Module    │ │Module    │ │Module    │             │  │
│  │  └──────────┘ └──────────┘ └──────────┘             │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐             │  │
│  │  │Echo      │ │Redis     │ │Lua       │ 第三方模块  │  │
│  │  │Module    │ │Module    │ │Module    │             │  │
│  │  └──────────┘ └──────────┘ └──────────┘             │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│                    后端服务器（Backend）                    │
│  • 应用服务器（FastCGI/uWSGI）                              │
│  • 数据库服务器                                             │
│  • 缓存服务器（Redis/Memcached）                            │
└────────────────────────────────────────────────────────────┘
```

#### 2.1.2 数据流向

**请求处理流程**：

```
1. 客户端发起 HTTP/HTTPS 请求 → Nginx
   ↓
2. Master 进程监听端口，将连接分配给 Worker 进程
   ↓
3. Worker 进程通过事件驱动接收请求
   ↓
4. Worker 根据配置使用相应模块处理请求
   • 静态文件 → 直接读取并返回
   • 动态请求 → 转发给后端（FastCGI/Proxy）
   ↓
5. 后端服务器处理并返回响应
   ↓
6. Worker 进程接收响应
   • 配置了缓存 → 缓存响应内容
   • 直接返回 → 发送给客户端
   ↓
7. 客户端接收响应
```

---

### 2.2 Master 进程与 Worker 进程

#### 2.2.1 Master 进程（管理进程）

**核心职责**：

| 职责 | 说明 | 重要性 |
|------|------|--------|
| **配置管理** | 读取、验证配置文件 | ✅ 核心功能 |
| **进程管理** | 创建、监控、重启 Worker 进程 | ✅ 核心功能 |
| **信号处理** | 处理管理员信号（reload、stop 等） | ✅ 核心功能 |
| **资源管理** | 管理共享内存、缓存等全局资源 | ⚠️ 辅助功能 |

**Master 进程工作流程**：

```
┌────────────────────────────────────────────────────────┐
│                  Master 进程启动流程                    │
├────────────────────────────────────────────────────────┤
│                                                          │
│  1. 启动阶段                                             │
│     ├─ 读取配置文件（nginx.conf）                       │
│     ├─ 验证配置语法                                     │
│     ├─ 初始化全局资源（共享内存、监听套接字）           │
│     └─ 创建指定数量的 Worker 进程                       │
│                                                          │
│  2. 运行阶段                                             │
│     ├─ 监听管理信号（USR1、USR2、HUP 等）              │
│     ├─ 监控 Worker 进程健康状态                         │
│     └─ 异常时重启 Worker 进程                           │
│                                                          │
│  3. 重载配置（Reload）                                   │
│     ├─ 重新读取配置文件                                 │
│     ├─ 验证新配置语法                                   │
│     ├─ 创建新的 Worker 进程（使用新配置）               │
│     ├─ 向旧 Worker 进程发送优雅退出信号                 │
│     └─ 旧 Worker 处理完当前请求后退出                   │
│                                                          │
└────────────────────────────────────────────────────────┘
```

#### 2.2.2 Worker 进程（工作进程）

**核心职责**：

| 职责 | 说明 | 特点 |
|------|------|------|
| **请求处理** | 处理客户端的实际 HTTP 请求 | 单线程异步非阻塞 |
| **连接管理** | 管理客户端连接的生命周期 | 事件驱动模型 |
| **负载均衡** | 多个 Worker 竞争接受连接 | 均衡分配请求 |
| **缓存处理** | 读写共享内存缓存 | 高效数据共享 |

**Worker 进程工作模型**：

```
┌────────────────────────────────────────────────────────┐
│            Worker 进程：事件驱动 + 异步非阻塞            │
├────────────────────────────────────────────────────────┤
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │           事件循环（Event Loop）                │    │
│  │                                                  │    │
│  │  while (true) {                                  │    │
│  │    // 1. 等待事件（使用 epoll/kqueue）           │    │
│  │    events = epoll_wait(epfd, ...);               │    │
│  │                                                  │    │
│  │    // 2. 遍历所有就绪事件                        │    │
│  │    for (event in events) {                       │    │
│  │      if (event.type == READ) {                   │    │
│  │        // 读事件：接收客户端数据                 │    │
│  │        read_from_client(event.fd);               │    │
│  │      }                                            │    │
│  │      else if (event.type == WRITE) {             │    │
│  │        // 写事件：发送响应数据                   │    │
│  │        write_to_client(event.fd);                │    │
│  │      }                                            │    │
│  │      else if (event.type == ACCEPT) {            │    │
│  │        // 接受事件：新客户端连接                 │    │
│  │        accept_new_connection();                  │    │
│  │      }                                            │    │
│  │    }                                              │    │
│  │  }                                                │    │
│  │                                                  │    │
│  └────────────────────────────────────────────────┘    │
│                                                          │
│  关键特性：                                              │
│  ✓ 单线程处理多个连接                                   │
│  ✓ 非阻塞 I/O（不等待数据就绪）                         │
│  ✓ 事件驱动（有事件才处理）                             │
│  ✓ 高效内存管理（内存池技术）                           │
│                                                          │
└────────────────────────────────────────────────────────┘
```

#### 2.2.3 Master-Worker 协作关系

```
┌────────────────────────────────────────────────────────┐
│              Master 与 Worker 的通信方式                │
├────────────────────────────────────────────────────────┤
│                                                          │
│  信号通信（Signal）：                                    │
│    Master → Worker                                       │
│    ├─ SIGTERM：立即终止                                 │
│    ├─ SIGQUIT：优雅退出（处理完当前请求）               │
│    ├─ SIGUSR1：重新打开日志文件                         │
│    └─ SIGUSR2：平滑升级二进制文件                       │
│                                                          │
│  共享内存（Shared Memory）：                             │
│    Worker ↔ Worker                                       │
│    ├─ 共享缓存数据                                      │
│    ├─ 负载均衡统计                                      │
│    └─ 限流计数器                                        │
│                                                          │
│  套接字（Socket）：                                      │
│    Master → Worker                                       │
│    └─ 传递监听套接字（继承文件描述符）                  │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**为什么采用 Master-Worker 模型？**

| 优势 | 说明 |
|------|------|
| **高可用性** | 单个 Worker 崩溃不影响其他 Worker |
| **热重载** | 可以无缝重载配置，不中断服务 |
| **资源隔离** | Worker 进程独立，内存故障不互相影响 |
| **负载均衡** | 多个 Worker 竞争接受连接，自动负载均衡 |
| **平滑升级** | 可以不停机升级 Nginx 二进制文件 |

---

### 2.3 Nginx 设计原则

#### 2.3.1 事件驱动模型

**核心思想**：不为每个连接创建线程/进程，而是用事件循环监听所有连接的状态变化。

```
┌────────────────────────────────────────────────────────┐
│              传统多线程模型 vs Nginx 事件驱动            │
├────────────────────────────────────────────────────────┤
│                                                          │
│  【传统模型】每连接一线程                                │
│  ┌──────┐     ┌────────┐                               │
│  │客户端1│────→│线程 1  │ ← 阻塞等待 I/O                 │
│  └──────┘     └────────┘                               │
│  ┌──────┐     ┌────────┐                               │
│  │客户端2│────→│线程 2  │ ← 阻塞等待 I/O                 │
│  └──────┘     └────────┘                               │
│  ┌──────┐     ┌────────┐                               │
│  │客户端N│────→│线程 N  │ ← 阻塞等待 I/O                 │
│  └──────┘     └────────┘                               │
│                                                          │
│  问题：                                                  │
│  ✗ 线程数量 = 连接数量（资源消耗大）                     │
│  ✗ 上下文切换频繁（性能下降）                           │
│  ✗ 阻塞等待 I/O（CPU 利用率低）                         │
│                                                          │
├────────────────────────────────────────────────────────┤
│                                                          │
│  【Nginx 模型】事件驱动 + 异步非阻塞                     │
│  ┌──────┐                                               │
│  │客户端1│─┐                                            │
│  └──────┘ │                                            │
│  ┌──────┐ │  ┌────────────────────────┐                │
│  │客户端2│─┼─→│  Worker 进程（单线程） │                │
│  └──────┘ │  │                        │                │
│  ┌──────┐ │  │  • 事件循环            │                │
│  │客户端N│─┘  │  • 非阻塞 I/O          │                │
│  └──────┘     │  • 同时处理多个连接    │                │
│               └────────────────────────┘                │
│                                                          │
│  优势：                                                  │
│  ✓ 单线程处理多连接（资源消耗低）                       │
│  ✓ 无上下文切换（性能高）                               │
│  ✓ 非阻塞 I/O（CPU 利用率高）                           │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**事件驱动工作流程**：

```
┌────────────────────────────────────────────────────────┐
│                 Nginx 事件处理流程                      │
├────────────────────────────────────────────────────────┤
│                                                          │
│  1. 监听事件                                             │
│     └─ epoll_wait() ← 等待任意连接有事件发生            │
│                                                          │
│  2. 事件到来（以 HTTP 请求为例）                         │
│     ├─ 连接事件（ACCEPT）                               │
│     │    └─ 新客户端连接 → accept() → 注册到 epoll      │
│     │                                                    │
│     ├─ 读事件（READ）                                   │
│     │    └─ 数据到达 → read() → 解析 HTTP 请求          │
│     │                                                    │
│     ├─ 写事件（WRITE）                                  │
│     │    └─ 可以写入 → write() → 发送 HTTP 响应         │
│     │                                                    │
│     └─ 关闭事件（CLOSE）                                │
│          └─ 连接关闭 → close() → 从 epoll 移除          │
│                                                          │
│  3. 非阻塞处理                                           │
│     • 如果数据未就绪 → 立即返回 → 处理其他事件          │
│     • 如果数据就绪 → 快速处理 → 继续监听事件            │
│                                                          │
│  4. 返回步骤 1（循环）                                   │
│                                                          │
└────────────────────────────────────────────────────────┘
```

#### 2.3.2 多进程 + 单线程模型

**架构特点**：

| 层次 | 说明 | 数量 | 职责 |
|------|------|------|------|
| **多进程** | Master + 多个 Worker | 1 Master + N Worker | 进程隔离、高可用 |
| **单线程** | 每个 Worker 内部单线程 | 1 线程/Worker | 简化编程、无锁竞争 |

**为什么 Worker 使用单线程？**

```
┌────────────────────────────────────────────────────────┐
│            单线程 vs 多线程（在 Worker 内部）            │
├────────────────────────────────────────────────────────┤
│                                                          │
│  【单线程模型】Nginx 采用                                │
│  ✓ 无锁竞争 → 性能高                                    │
│  ✓ 编程简单 → 不需要考虑线程安全                        │
│  ✓ 事件驱动 → 单线程足以处理大量连接                    │
│  ✓ 内存占用低 → 无需为每个线程分配栈空间                │
│                                                          │
│  【多线程模型】传统服务器                                │
│  ✗ 需要锁机制 → 性能开销                                │
│  ✗ 上下文切换 → CPU 消耗                                │
│  ✗ 复杂度高 → 死锁、竞态条件等问题                      │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**Worker 进程数量配置**：

```nginx
# 推荐配置：Worker 数量 = CPU 核心数
worker_processes auto;  # 自动检测 CPU 核心数

# 或手动指定
worker_processes 4;     # 4 个 Worker 进程
```

#### 2.3.3 异步非阻塞 I/O

**阻塞 vs 非阻塞对比**：

```
┌────────────────────────────────────────────────────────┐
│              阻塞 I/O vs 非阻塞 I/O                     │
├────────────────────────────────────────────────────────┤
│                                                          │
│  【阻塞 I/O】                                            │
│  Thread:  [等待数据]──────────────→ [处理数据]          │
│              ↑                                           │
│            浪费时间                                      │
│                                                          │
│  【非阻塞 I/O】                                          │
│  Thread:  [尝试读取] → [处理其他任务] → [再次读取]      │
│              ↓              ↓               ↓            │
│           立即返回      高效利用时间      数据就绪       │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**非阻塞 I/O 示例**：

```c
// 阻塞 I/O（传统方式）
int blocking_read() {
    char buf[1024];
    read(fd, buf, 1024);  // 如果数据未就绪，会一直等待
    return process(buf);
}

// 非阻塞 I/O（Nginx 方式）
int nonblocking_read() {
    char buf[1024];
    fcntl(fd, F_SETFL, O_NONBLOCK);  // 设置非阻塞

    int n = read(fd, buf, 1024);
    if (n < 0 && errno == EAGAIN) {
        // 数据未就绪，立即返回，去处理其他任务
        return AGAIN;
    }
    return process(buf);  // 数据就绪，处理
}
```

#### 2.3.4 内存池和缓存机制

**内存池作用**：

| 功能 | 说明 | 优势 |
|------|------|------|
| **预分配内存** | 启动时分配大块内存 | 减少系统调用 |
| **快速分配** | 从内存池获取而非 malloc | 性能提升 10 倍+ |
| **统一释放** | 请求结束统一释放整个池 | 避免内存泄漏 |
| **减少碎片** | 集中管理内存 | 提高内存利用率 |

**缓存机制**：

```
┌────────────────────────────────────────────────────────┐
│                  Nginx 缓存架构                         │
├────────────────────────────────────────────────────────┤
│                                                          │
│  客户端请求 → Nginx                                      │
│                ↓                                         │
│      查找缓存？                                          │
│       ├─ 命中 → 直接返回缓存内容（快速响应）            │
│       └─ 未命中 → 请求后端服务器                        │
│                    ↓                                     │
│              获取响应内容                                │
│                    ↓                                     │
│          ┌─ 存入缓存（下次使用）                         │
│          └─ 返回给客户端                                 │
│                                                          │
│  缓存存储位置：                                          │
│    • 共享内存（快速访问）                                │
│    • 磁盘文件（大容量）                                  │
│                                                          │
└────────────────────────────────────────────────────────┘
```

---

### 2.4 Nginx 模块架构

#### 2.4.1 模块分类

Nginx 由内核和模块组成，模块化架构使得功能可以灵活扩展。

```
┌────────────────────────────────────────────────────────┐
│                   Nginx 模块层次结构                     │
├────────────────────────────────────────────────────────┤
│                                                          │
│  【核心模块】Core Modules                                │
│  ├─ Events Module   → 事件处理（epoll/kqueue）          │
│  ├─ HTTP Module     → HTTP 协议处理                     │
│  └─ Mail Module     → 邮件代理（IMAP/POP3/SMTP）        │
│                                                          │
│  【基础模块】Base Modules（HTTP 级别）                   │
│  ├─ Core Module     → HTTP 基础功能（server、location） │
│  ├─ Access Module   → 访问控制（allow/deny）            │
│  ├─ FastCGI Module  → FastCGI 协议支持                  │
│  ├─ Proxy Module    → 反向代理                          │
│  ├─ Upstream Module → 负载均衡                          │
│  ├─ Rewrite Module  → URL 重写                          │
│  ├─ SSL Module      → HTTPS 支持                        │
│  └─ Gzip Module     → 压缩传输                          │
│                                                          │
│  【第三方模块】Third-party Modules                       │
│  ├─ Echo Module     → 调试输出                          │
│  ├─ Redis Module    → Redis 缓存                        │
│  ├─ Lua Module      → Lua 脚本（OpenResty）             │
│  ├─ VTS Module      → 流量统计                          │
│  └─ FLV Module      → 流媒体支持                        │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**模块参考资料**：https://nginx.org/en/docs/

#### 2.4.2 常用模块说明

| 模块类型 | 模块名称 | 功能说明 | 使用场景 |
|---------|---------|---------|---------|
| **核心** | Events | 事件驱动（epoll/kqueue） | 高并发连接处理 |
| **核心** | HTTP | HTTP 协议处理 | Web 服务器 |
| **基础** | Proxy | 反向代理 | 后端服务负载均衡 |
| **基础** | FastCGI | FastCGI 协议 | PHP/Python 应用 |
| **基础** | Upstream | 负载均衡组 | 多后端服务器 |
| **基础** | Rewrite | URL 重写 | 伪静态、重定向 |
| **基础** | SSL | HTTPS 支持 | 加密传输 |
| **基础** | Gzip | 压缩传输 | 减少带宽消耗 |
| **第三方** | Lua | 脚本扩展 | 灵活业务逻辑 |

---

### 2.5 Nginx vs Apache

#### 2.5.1 工作模式对比

| 对比项 | Nginx | Apache |
|-------|-------|--------|
| **工作模式** | 异步非阻塞 | 同步阻塞（prefork）或异步（worker/event） |
| **事件模型** | epoll（Linux）/ kqueue（BSD） | select/poll（低效）/ epoll（仅 event 模式） |
| **进程管理** | Master-Worker（Worker 异步非阻塞） | 多进程或多线程（prefork/worker/event） |
| **并发性能** | ⭐⭐⭐⭐⭐ 处理数万并发 | ⭐⭐⭐ 数千并发（取决于模式） |
| **资源消耗** | ⭐⭐⭐⭐⭐ 内存占用低 | ⭐⭐⭐ 内存占用较高 |
| **静态文件** | ⭐⭐⭐⭐⭐ 极快 | ⭐⭐⭐⭐ 快 |
| **动态内容** | ⭐⭐⭐⭐ 反向代理 | ⭐⭐⭐⭐⭐ 内置模块（mod_php） |
| **配置** | ⭐⭐⭐⭐⭐ 简洁 | ⭐⭐⭐ 复杂（.htaccess） |

#### 2.5.2 Apache 三种工作模式

**模式对比表**：

| 工作模式 | I/O 模型 | 架构 | 并发性能 | 内存占用 | 稳定性 | 推荐场景 |
|---------|---------|------|---------|---------|--------|---------|
| **Prefork** | 同步阻塞 | 多进程 | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | 小型网站、静态内容 |
| **Worker** | 异步非阻塞 | 多进程+多线程 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | 动态内容、中等并发 |
| **Event** | 异步非阻塞 | 多进程+多线程+事件驱动 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 高并发、长连接 |

**详细对比**：

```
┌────────────────────────────────────────────────────────┐
│               Apache Prefork 模式                       │
├────────────────────────────────────────────────────────┤
│  架构：每连接一进程（同步阻塞）                          │
│  ┌────┐  ┌────┐  ┌────┐  ┌────┐                       │
│  │进程1│ │进程2│ │进程3│ │进程N│                       │
│  └─┬──┘ └─┬──┘ └─┬──┘ └─┬──┘                       │
│    ↓      ↓      ↓      ↓                             │
│  ┌────┐ ┌────┐ ┌────┐ ┌────┐                         │
│  │连接1│ │连接2│ │连接3│ │连接N│                       │
│  └────┘ └────┘ └────┘ └────┘                         │
│                                                          │
│  优点：稳定性好、进程隔离                                │
│  缺点：高并发性能差、资源消耗大                          │
├────────────────────────────────────────────────────────┤
│               Apache Worker 模式                        │
├────────────────────────────────────────────────────────┤
│  架构：多进程 + 多线程（异步非阻塞）                     │
│  ┌─────────────────────────────────┐                   │
│  │     进程 1                       │                   │
│  │  ┌──────┐ ┌──────┐ ┌──────┐    │                   │
│  │  │线程1 │ │线程2 │ │线程N │    │                   │
│  │  └──┬───┘ └──┬───┘ └──┬───┘    │                   │
│  └─────┼────────┼────────┼─────────┘                   │
│        ↓        ↓        ↓                              │
│     连接1~N  连接N+1~M  连接M+1~X                        │
│                                                          │
│  优点：并发性能好、内存占用低                            │
│  缺点：线程不安全风险、长连接占用线程                    │
├────────────────────────────────────────────────────────┤
│               Apache Event 模式                         │
├────────────────────────────────────────────────────────┤
│  架构：多进程 + 多线程 + 事件驱动（异步非阻塞）          │
│  ┌─────────────────────────────────────┐               │
│  │     进程 1                           │               │
│  │  ┌──────────┐  ┌──────────────┐    │               │
│  │  │管理线程  │  │工作线程池    │    │               │
│  │  │（长连接）│  │（处理请求）  │    │               │
│  │  └─────┬────┘  └──────────────┘    │               │
│  └────────┼─────────────────────────────┘               │
│           ↓                                              │
│     统一管理长连接，按需分配工作线程                     │
│                                                          │
│  优点：高并发、高效处理长连接                            │
│  缺点：配置复杂、兼容性问题                              │
└────────────────────────────────────────────────────────┘
```

---

### 2.6 C10K 问题

#### 2.6.1 什么是 C10K 问题

**定义**：C10K = "10 thousand clients" problem

```
┌────────────────────────────────────────────────────────┐
│                    C10K 问题背景                        │
├────────────────────────────────────────────────────────┤
│                                                          │
│  时间：1999 年由 Dan Kegel 提出                         │
│  问题：如何让单台服务器支持 10000 个并发连接？          │
│                                                          │
│  【当时的技术局限】                                      │
│  • 硬件配置低（内存小、CPU 弱）                         │
│  • 同步阻塞 I/O 模型效率低                              │
│  • 传统方式：1 连接 = 1 进程                            │
│    → 10000 连接 = 10000 进程 → 服务器崩溃！            │
│                                                          │
│  【核心矛盾】                                            │
│  进程资源消耗 vs 并发连接数                             │
│    ↓                                                     │
│  传统方式无法扩展到 10K 并发                            │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**参考资料**：http://www.kegel.com/c10k.html

#### 2.6.2 C10K 问题的本质

**核心矛盾**：CPU 资源不足

```
┌────────────────────────────────────────────────────────┐
│              C10K 问题的 CPU 瓶颈分析                   │
├────────────────────────────────────────────────────────┤
│                                                          │
│  1️⃣ 进程/线程切换开销                                    │
│     • 10000 个进程 → 频繁上下文切换                     │
│     • 每次切换保存/恢复寄存器、页表等                   │
│     • CPU 大量时间消耗在切换上                          │
│                                                          │
│  2️⃣ 数据拷贝开销                                         │
│     • 内核空间 ↔ 用户空间的数据拷贝                     │
│     • 每个连接都需要独立的缓冲区                        │
│                                                          │
│  3️⃣ 缓存命中率下降                                       │
│     • 大量任务竞争 CPU 缓存                             │
│     • 缓存失效 → 内存访问 → 性能下降                    │
│                                                          │
│  4️⃣ 调度算法失效                                         │
│     • 任务数远超 CPU 核心数                             │
│     • 调度器压力大 → 调度延迟增加                       │
│                                                          │
└────────────────────────────────────────────────────────┘
```

#### 2.6.3 解决 C10K 问题的方法

**核心思路**：减少进程/线程数量，提高单个进程的并发处理能力。

```
┌────────────────────────────────────────────────────────┐
│              C10K 问题解决方案                          │
├────────────────────────────────────────────────────────┤
│                                                          │
│  ① 优化操作系统配置                                     │
│     • 提高文件描述符限制（ulimit -n）                   │
│     • 优化 TCP 参数（缓冲区、超时）                     │
│                                                          │
│  ② 采用高效的 I/O 模型 ⭐⭐⭐                            │
│     • select → poll → epoll                             │
│     • 异步 I/O（AIO）                                   │
│     • 内存映射（mmap）                                  │
│                                                          │
│  ③ 改变事件处理模型 ⭐⭐⭐⭐⭐                            │
│     • 事件驱动编程（Nginx 的核心）                      │
│     • 单线程 + 事件循环 + 非阻塞 I/O                    │
│     • 线程池技术                                        │
│                                                          │
│  ④ 使用高性能服务器软件                                 │
│     • Nginx（事件驱动 + 异步非阻塞）                    │
│     • Node.js（单线程 + 事件循环）                      │
│     • Netty（Java 异步框架）                            │
│                                                          │
└────────────────────────────────────────────────────────┘
```

**I/O 模型演进**：

| I/O 模型 | 监控方式 | 性能 | 缺点 | 典型应用 |
|---------|---------|------|------|---------|
| **select** | 遍历文件描述符集合 | ⭐⭐ | 1024 文件描述符限制 | 传统服务器 |
| **poll** | 遍历文件描述符集合 | ⭐⭐⭐ | 无数量限制，但仍需遍历 | Apache worker |
| **epoll** | 事件通知（边缘触发） | ⭐⭐⭐⭐⭐ | 仅 Linux 支持 | Nginx、Redis |
| **kqueue** | 事件通知 | ⭐⭐⭐⭐⭐ | 仅 BSD/macOS 支持 | Nginx（FreeBSD） |

---

## 🐳 第三部分：Docker 环境说明

### 3.1 Docker Compose 配置

本项目使用 Docker Compose 搭建 Nginx 学习环境，采用 **Rocky Linux 9 源码编译** 方式安装 Nginx。

#### 3.1.1 网络拓扑

```
Docker Bridge 网络：nginx-net (10.0.7.0/24)
├── 10.0.7.1   - 网关（Docker 网桥）
└── 10.0.7.10  - Nginx 服务器（nginx-rocky-compile）
    ├── Dockerfile: Dockerfile.rocky-compile
    ├── 编译参数：详见下方说明
    └── 端口映射：8080 → 80
```

#### 3.1.2 Docker Compose 配置说明

```yaml
version: '3.8'

services:
  nginx-demo:
    container_name: nginx-rocky-compile
    hostname: nginx-rocky-compile
    build:
      context: ..                          # 构建上下文为父目录
      dockerfile: Dockerfile.rocky-compile # 使用 Rocky 编译版 Dockerfile
    networks:
      nginx-net:
        ipv4_address: 10.0.7.10            # 固定 IP 地址
    ports:
      - "8080:80"                          # 主机 8080 映射到容器 80
    command: sh -c "tail -f /dev/null"     # 保持容器运行（不启动 Nginx）
    tty: true                              # 分配伪终端
    stdin_open: true                       # 保持 stdin 打开

networks:
  nginx-net:
    driver: bridge                         # 使用桥接网络
    ipam:
      config:
        - subnet: 10.0.7.0/24             # 子网
          gateway: 10.0.7.1               # 网关
```

**⚠️ 重要说明**：

- `command: tail -f /dev/null`：容器启动后不自动启动 Nginx，而是保持运行状态，便于用户手动进入容器学习。
- 如果需要自动启动 Nginx，请删除 `command` 行，使用 Dockerfile 中的默认 CMD。

---

### 3.2 Dockerfile 编译配置

#### 3.2.1 编译环境说明

**基础镜像**：`docker-man-base:latest`（基于 Rocky Linux 9）

**Nginx 版本**：1.26.0（Stable 版本）

#### 3.2.2 编译依赖包

| 依赖分组 | 包名 | 作用 |
|---------|------|------|
| **基础编译环境** | gcc, make, gcc-c++ | C/C++ 编译器 |
| | glibc, glibc-devel | C 标准库 |
| | pcre, pcre-devel | 正则表达式库（location 匹配） |
| | openssl, openssl-devel | SSL/TLS 加密库（HTTPS） |
| | systemd-devel | systemd 集成 |
| | zlib-devel | 压缩库（gzip） |
| **额外功能模块** | libxml2, libxml2-devel | XML 处理 |
| | libxslt, libxslt-devel | XSLT 转换 |
| | gd, gd-devel | 图像处理 |
| **工具** | wget, tar | 下载和解压 |

#### 3.2.3 编译配置参数

```bash
./configure \
  --prefix=/data/server/nginx \              # 安装路径
  --user=nginx \                             # 运行用户
  --group=nginx \                            # 运行用户组
  --with-http_ssl_module \                   # HTTPS 支持
  --with-http_v2_module \                    # HTTP/2 支持
  --with-http_realip_module \                # 真实 IP 获取
  --with-http_stub_status_module \           # 状态页支持
  --with-http_gzip_static_module \           # 预压缩文件支持
  --with-pcre \                              # PCRE 正则表达式
  --with-stream \                            # TCP/UDP 四层代理
  --with-stream_ssl_module \                 # 四层 SSL 支持
  --with-stream_realip_module                # 四层真实 IP
```

**编译参数说明**：

| 参数 | 说明 | 重要性 |
|------|------|--------|
| `--prefix` | 安装目录 | ✅ 必需 |
| `--user/--group` | 运行用户/组 | ✅ 必需（安全） |
| `--with-http_ssl_module` | HTTPS 支持 | ⭐⭐⭐⭐⭐ |
| `--with-http_v2_module` | HTTP/2 协议 | ⭐⭐⭐⭐ |
| `--with-http_stub_status_module` | 状态页 | ⭐⭐⭐⭐ |
| `--with-stream` | 四层代理（TCP/UDP） | ⭐⭐⭐⭐ |

#### 3.2.4 目录结构

```
/data/server/nginx/
├── sbin/nginx           # Nginx 二进制文件
├── conf/                # 配置文件目录
│   ├── nginx.conf       # 主配置文件
│   ├── mime.types       # MIME 类型
│   └── ...
├── html/                # 默认网站根目录
│   ├── index.html       # 默认首页
│   └── 50x.html         # 错误页面
├── logs/                # 日志目录
│   ├── access.log       # 访问日志
│   └── error.log        # 错误日志
└── run/                 # PID 文件目录
    └── nginx.pid        # 进程 PID
```

---

## 🚀 第四部分：启动与验证

### 4.1 启动 Docker 环境

```bash
# 1. 进入项目目录
cd /home/www/docker-man/07.nginx/01.manual-architecture

# 2. 构建并启动容器
docker compose up -d

# 3. 检查容器状态
docker compose ps

# 预期输出：
# NAME                  STATUS    PORTS
# nginx-rocky-compile   Up        0.0.0.0:8080->80/tcp

# 4. 查看网络配置
docker network inspect 01manual-architecture_nginx-net

# 5. 查看容器 IP
docker inspect nginx-rocky-compile | grep IPAddress
# "IPAddress": "10.0.7.10"
```

---

### 4.2 验证 Nginx 安装

#### 4.2.1 进入容器

```bash
docker compose exec -it nginx-demo bash
```

#### 4.2.2 检查 Nginx 版本

```bash
# 查看版本和编译参数
nginx -V

# 预期输出：
# nginx version: nginx/1.26.0
# built by gcc 11.4.1 20231218 (Red Hat 11.4.1-3) (GCC)
# built with OpenSSL 3.0.7 1 Nov 2022
# TLS SNI support enabled
# configure arguments: --prefix=/data/server/nginx --user=nginx ...
```

#### 4.2.3 检查目录结构

```bash
# 查看安装目录
ls -lh /data/server/nginx/

# 预期输出：
# drwxr-xr-x 2 nginx nginx 4.0K conf
# drwxr-xr-x 2 nginx nginx 4.0K html
# drwxr-xr-x 2 nginx nginx 4.0K logs
# drwxr-xr-x 2 nginx nginx 4.0K run
# drwxr-xr-x 2 nginx nginx 4.0K sbin

# 查看二进制文件
which nginx
# /usr/local/bin/nginx → /data/server/nginx/sbin/nginx
```

#### 4.2.4 测试配置文件

```bash
# 测试配置语法
nginx -t

# 预期输出：
# nginx: the configuration file /data/server/nginx/conf/nginx.conf syntax is ok
# nginx: configuration file /data/server/nginx/conf/nginx.conf test is successful
```

#### 4.2.5 启动 Nginx

```bash
# 启动 Nginx
nginx

# 检查进程
ps aux | grep nginx

# 预期输出：
# nginx    1  0.0  0.1  master process nginx
# nginx   10  0.0  0.2  worker process

# 查看监听端口
netstat -tlnp | grep nginx
# tcp  0  0  0.0.0.0:80  0.0.0.0:*  LISTEN  1/nginx
```

#### 4.2.6 测试访问

```bash
# 容器内测试
curl http://localhost

# 宿主机测试
curl http://localhost:8080

# 预期输出：
# <!DOCTYPE html>
# <html>
# <head>
# <title>Welcome to nginx!</title>
# ...
```

---

### 4.3 查看 Master 和 Worker 进程

```bash
# 查看进程树
pstree -p | grep nginx

# 预期输出：
# nginx(1234)─┬─nginx(1235)  ← Worker 1
#             ├─nginx(1236)  ← Worker 2
#             ├─nginx(1237)  ← Worker 3
#             └─nginx(1238)  ← Worker 4

# 查看进程详情
ps aux | grep nginx

# 预期输出：
# USER       PID  %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
# root      1234  0.0  0.1  20300  1200 ?     Ss   10:00   0:00 nginx: master process
# nginx     1235  0.0  0.2  20700  2400 ?     S    10:00   0:00 nginx: worker process
# nginx     1236  0.0  0.2  20700  2400 ?     S    10:00   0:00 nginx: worker process
# nginx     1237  0.0  0.2  20700  2400 ?     S    10:00   0:00 nginx: worker process
# nginx     1238  0.0  0.2  20700  2400 ?     S    10:00   0:00 nginx: worker process

# 查看 Worker 数量
grep "worker_processes" /data/server/nginx/conf/nginx.conf

# 如果是 auto，查看 CPU 核心数
nproc
```

**进程说明**：

| 进程类型 | PID | 用户 | 说明 |
|---------|-----|------|------|
| **Master 进程** | 1234 | root | 管理进程，不处理请求 |
| **Worker 进程** | 1235-1238 | nginx | 工作进程，处理客户端请求 |

---

## 📋 第五部分：学习检查清单

### 5.1 基础知识

- [ ] 理解 Nginx 是什么，核心功能有哪些
- [ ] 掌握 Nginx 的发展历史和版本分类
- [ ] 理解 Mainline、Stable、Legacy 版本的区别
- [ ] 知道如何选择合适的 Nginx 版本

### 5.2 架构理解

- [ ] 理解 Nginx 的 Master-Worker 架构
- [ ] 掌握 Master 进程的职责和工作流程
- [ ] 掌握 Worker 进程的职责和工作模型
- [ ] 理解 Master 和 Worker 的通信方式
- [ ] 理解为什么采用 Master-Worker 模型

### 5.3 设计原则

- [ ] 理解事件驱动模型的核心思想
- [ ] 理解异步非阻塞 I/O 的工作原理
- [ ] 掌握 Nginx 单线程处理多连接的机制
- [ ] 理解内存池和缓存机制的作用
- [ ] 理解 Nginx 与传统多线程模型的区别

### 5.4 模块架构

- [ ] 掌握 Nginx 的模块分类（核心、基础、第三方）
- [ ] 理解常用模块的功能和使用场景
- [ ] 了解如何扩展 Nginx 功能（第三方模块）

### 5.5 Nginx vs Apache

- [ ] 理解 Nginx 和 Apache 的工作模式差异
- [ ] 掌握 Apache 三种模式（prefork、worker、event）
- [ ] 理解各种模式的优缺点和适用场景
- [ ] 知道何时选择 Nginx，何时选择 Apache

### 5.6 C10K 问题

- [ ] 理解 C10K 问题的背景和定义
- [ ] 掌握 C10K 问题的本质（CPU 瓶颈）
- [ ] 理解解决 C10K 问题的核心思路
- [ ] 掌握 I/O 模型的演进（select → poll → epoll）
- [ ] 理解 Nginx 如何解决 C10K 问题

### 5.7 Docker 环境

- [ ] 理解 Docker Compose 配置中的网络设置
- [ ] 掌握 Dockerfile 编译参数的含义
- [ ] 能够独立构建和启动 Nginx 容器
- [ ] 能够验证 Nginx 安装和进程状态

---

## ❓ 第六部分：常见问题

### Q1: 为什么 Nginx 比 Apache 性能更好?

**答**：核心原因是**异步非阻塞 I/O + 事件驱动**。

```
Apache（prefork）：
  1 连接 = 1 进程（阻塞等待 I/O）
  10000 连接 = 10000 进程 → 系统崩溃

Nginx（事件驱动）：
  1 Worker 进程 = 处理多个连接（非阻塞 I/O）
  10000 连接 = 4 个 Worker 进程 → 高效运行
```

---

### Q2: Worker 进程数量应该设置为多少？

**答**：**推荐设置为 CPU 核心数**。

```nginx
# 自动检测（推荐）
worker_processes auto;

# 手动指定（CPU 核心数）
worker_processes 4;  # 4 核 CPU

# 查看 CPU 核心数
nproc
```

**原因**：
- Worker 进程是 CPU 密集型任务。
- 进程数 = CPU 核心数时，可以避免进程切换开销。
- 过多进程会导致频繁上下文切换，性能反而下降。

---

### Q3: 为什么 Worker 进程使用单线程而不是多线程？

**答**：单线程 + 事件驱动已经足够高效，无需多线程的复杂性。

| 单线程模型 | 多线程模型 |
|-----------|-----------|
| ✅ 无锁竞争 | ❌ 需要锁机制 |
| ✅ 编程简单 | ❌ 线程安全问题 |
| ✅ 事件驱动已足够高效 | ❌ 上下文切换开销 |
| ✅ 内存占用低 | ❌ 每个线程需要独立栈 |

---

### Q4: 什么是 C10K 问题？Nginx 如何解决？

**答**：C10K = 单台服务器如何支持 10000 个并发连接。

**传统方式**：1 连接 = 1 进程 → 10000 进程 → 系统崩溃

**Nginx 方式**：
1. **事件驱动**：不为每个连接创建进程/线程。
2. **epoll**：高效监控大量文件描述符。
3. **异步非阻塞 I/O**：不等待 I/O，继续处理其他任务。
4. **结果**：单个 Worker 进程可处理数万连接。

---

### Q5: epoll 和 select 有什么区别？

**答**：

| 对比项 | select | epoll |
|-------|--------|-------|
| **监控方式** | 遍历所有文件描述符 | 仅通知就绪的文件描述符 |
| **性能** | O(n) | O(1) |
| **文件描述符限制** | 1024（默认） | 无限制 |
| **支持平台** | 所有平台 | 仅 Linux |

**epoll 优势**：
- **事件通知**：只处理就绪的连接，无需遍历。
- **无限制**：可以监控数十万个连接。
- **高效**：适合高并发场景。

---

### Q6: Master 进程可以处理客户端请求吗？

**答**：**不能**。Master 进程只负责管理 Worker 进程，不处理实际的客户端请求。

```
Master 进程职责：
  ✓ 读取配置文件
  ✓ 创建和管理 Worker 进程
  ✓ 处理管理员信号（reload、stop）
  ✗ 不处理客户端请求

Worker 进程职责：
  ✓ 处理客户端请求
  ✓ 事件驱动 + 异步非阻塞 I/O
  ✓ 负载均衡（多个 Worker 竞争接受连接）
```

---

## 🧹 清理环境

```bash
# 1. 停止并删除容器
docker compose down

# 2. 删除镜像（可选）
docker rmi 01manual-architecture_nginx-demo

# 3. 删除网络（可选）
docker network rm 01manual-architecture_nginx-net
```

---

## 📖 参考资料

- **Nginx 官方文档**：https://nginx.org/en/docs/
- **Nginx 下载页面**：https://nginx.org/en/download.html
- **C10K 问题**：http://www.kegel.com/c10k.html
- **Nginx 源码**：https://github.com/nginx/nginx
- **OpenResty**：https://openresty.org/
- **Tengine**：https://tengine.taobao.org/

---

## 🔗 相关项目

- **07.nginx/01.manual-architecture**：本项目（Nginx 架构解读）
- **07.nginx/02.manual-compile-ubuntu**：Ubuntu 源码编译实践
- **07.nginx/03.manual-binary-install**：二进制安装实践

---

**完成时间**：2025-01-12
**文档版本**：v1.0（初始版本）
**维护者**：docker-man 项目组
